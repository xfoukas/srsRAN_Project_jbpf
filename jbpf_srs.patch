diff --git a/CMakeLists.txt b/CMakeLists.txt
index 8814764c5..926c49d1d 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -134,7 +134,7 @@ endif (ENABLE_DPDK)
 if (ENABLE_JBPF)
     set(JBPF_EXPERIMENTAL_FEATURES ON CACHE BOOL "Enable jbpf experimental features" FORCE)
     set(JBPF_STATIC ON CACHE BOOL "Build jbpf as static library" FORCE)
-    add_subdirectory(external/jbpf EXCLUDE_FROM_ALL)
+    add_subdirectory(external/jbpf)    
     add_definitions(-DJBPF_ENABLED)
     include_directories(${JBPF_LIB_HEADER_FILES})
     include_directories(${JBPF_IO_HEADER_FILES})
@@ -142,13 +142,15 @@ if (ENABLE_JBPF)
     include_directories(${JBPF_COMMON_HEADERS})
     include_directories(${JBPF_LCM_IPC_HEADER_FILES})
     include_directories(${JBPF_CK_HEADER_FILES})
-    include_directories(include/srsran/jbpf)
+    set(JBPF_SRSRAN_HEADER_FILES ${CMAKE_CURRENT_SOURCE_DIR}/include/srsran/jbpf)
+    include_directories(${JBPF_SRSRAN_HEADER_FILES})
+    add_subdirectory(srsran_jbpf)
+    include_directories(${SRSRAN_VERIFIER_SPECS_HEADERS})
     set (ENABLE_JBPF CACHE ON BOOL "jbpf enabled")
 else (ENABLE_JBPF)
     unset(JBPF_ENABLED CACHE)
 endif (ENABLE_JBPF)
 
-
 ########################################################################
 # ENABLE_EXPORT
 ########################################################################
diff --git a/external/jbpf b/external/jbpf
index 9a25032f8..9e31c08b8 160000
--- a/external/jbpf
+++ b/external/jbpf
@@ -1 +1 @@
-Subproject commit 9a25032f83b3d4038211d3042f9509a13438528a
+Subproject commit 9e31c08b86d3acd65b575283197ca15aca016841
diff --git a/include/srsran/jbpf/jbpf_srsran_contexts.h b/include/srsran/jbpf/jbpf_srsran_contexts.h
new file mode 100644
index 000000000..ac183a89d
--- /dev/null
+++ b/include/srsran/jbpf/jbpf_srsran_contexts.h
@@ -0,0 +1,44 @@
+#ifndef JBPF_SRSRAN_CONTEXTS_H
+#define JBPF_SRSRAN_CONTEXTS_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+#include <stdint.h>
+
+#include "jbpf_helper_api_defs_ext.h"
+
+typedef enum {
+    JBPF_PROG_TYPE_SRSRAN_OFH = CUSTOM_PROGRAM_START_ID,
+    JBPF_PROG_TYPE_SRSRAN_LAYER2,
+} jbpf_srsran_index_e;
+
+/* OFH context*/
+struct jbpf_ran_ofh_ctx {
+  uint64_t data; /* Pointer to beginning of buffer with int16_t IQ samples */
+  uint64_t data_end; /* Pointer to end+1 of packet */
+  uint64_t meta_data; /* Used for the program to store metadata */
+  /* Combination of frame, slot and cell_id, provide a unique
+     context for an execution pipeline */
+  uint16_t ctx_id; /* Context id (could be implementation specific) */
+  uint8_t direction; /* 0 DL, 1 UL */
+};
+
+/* L2 context*/
+struct jbpf_ran_layer2_ctx {
+    uint64_t data; /* Pointer to beginning of variable-sized L2 struct */
+    uint64_t data_end; /* Pointer to end+1 of variable-sized struct */
+    uint64_t meta_data; /* Used for the program to store metadata */
+    uint16_t ctx_id; /* Context id (could be implementation specific) */
+    uint16_t frame; /* 3GPP frame number */
+    uint16_t slot; /* 3GPP slot number */
+    uint16_t cell_id; /* Cell id */
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // JBPF_SRSRAN_CONTEXTS_H
diff --git a/include/srsran/jbpf/jbpf_srsran_defs.h b/include/srsran/jbpf/jbpf_srsran_defs.h
index 11bda164e..5009663e5 100644
--- a/include/srsran/jbpf/jbpf_srsran_defs.h
+++ b/include/srsran/jbpf/jbpf_srsran_defs.h
@@ -35,27 +35,4 @@ struct jbpf_bsr_update
     uint8_t num_bsr_report;
     struct jbpf_bsr_report bsr_report[JBPF_MAX_UE_SUPPORTED];
 };
-
-/* OFH context*/
-struct jbpf_ran_ofh_ctx {
-  uint64_t data; /* Pointer to beginning of buffer with int16_t IQ samples */
-  uint64_t data_end; /* Pointer to end+1 of packet */
-  uint64_t meta_data; /* Used for the program to store metadata */
-  /* Combination of frame, slot and cell_id, provide a unique
-     context for an execution pipeline */
-  uint16_t ctx_id; /* Context id (could be implementation specific) */
-  uint8_t direction; /* 0 DL, 1 UL */
-};
-
-/* L2 context*/
-struct jbpf_ran_layer2_ctx {
-    uint64_t data; /* Pointer to beginning of variable-sized L2 struct */
-    uint64_t data_end; /* Pointer to end+1 of variable-sized struct */
-    uint64_t meta_data; /* Used for the program to store metadata */
-    uint16_t ctx_id; /* Context id (could be implementation specific) */
-    uint16_t frame; /* 3GPP frame number */
-    uint16_t slot; /* 3GPP slot number */
-    uint16_t cell_id; /* Cell id */
-};
-
 #endif
\ No newline at end of file
diff --git a/init_modules.sh b/init_modules.sh
new file mode 100755
index 000000000..7b024ac3f
--- /dev/null
+++ b/init_modules.sh
@@ -0,0 +1,2 @@
+git submodule update --init 
+
diff --git a/srsran_jbpf/CMakeLists.txt b/srsran_jbpf/CMakeLists.txt
new file mode 100644
index 000000000..1713f46e0
--- /dev/null
+++ b/srsran_jbpf/CMakeLists.txt
@@ -0,0 +1,23 @@
+cmake_minimum_required(VERSION 3.16)
+
+project(srsranJbpf)
+
+set(JBPF_PATH $ENV{JBPF_PATH})
+set(JBPF_LIB_DIR $ENV{JBPF_OUT_DIR}/lib)
+
+set(OUTPUT_DIR ${CMAKE_SOURCE_DIR}/out)
+
+add_subdirectory(verifier)
+add_subdirectory(reverse_proxy)
+
+
+add_custom_target(copy-srsran-jbpf-headers ALL)
+add_custom_command(TARGET copy-srsran-jbpf-headers POST_BUILD
+  COMMAND ${CMAKE_COMMAND} -E make_directory ${OUTPUT_DIR}/inc/
+  COMMAND ${CMAKE_COMMAND} -E copy  ${JBPF_SRSRAN_HEADER_FILES}/* ${OUTPUT_DIR}/inc/
+)
+
+
+######## Export header files for other projects ############
+set(SRSRAN_VERIFIER_SPECS_HEADERS ${SRSRAN_VERIFIER_SPECS_HEADERS} PARENT_SCOPE)
+
diff --git a/srsran_jbpf/docker_build/Dockerfile b/srsran_jbpf/docker_build/Dockerfile
new file mode 100644
index 000000000..475064a6b
--- /dev/null
+++ b/srsran_jbpf/docker_build/Dockerfile
@@ -0,0 +1,11 @@
+FROM mcr.microsoft.com/mirror/docker/library/ubuntu:22.04
+
+ENV DEBIAN_FRONTEND=noninteractive
+SHELL ["/bin/bash", "-c"]
+
+RUN echo "*** Installing packages"
+RUN apt update --fix-missing
+RUN apt install -y libboost-dev git libboost-program-options-dev libboost-filesystem-dev
+
+COPY ./out /out
+ENTRYPOINT ["/bin/bash"]
diff --git a/srsran_jbpf/docker_build/build_image.sh b/srsran_jbpf/docker_build/build_image.sh
new file mode 100755
index 000000000..cae9d7760
--- /dev/null
+++ b/srsran_jbpf/docker_build/build_image.sh
@@ -0,0 +1,22 @@
+#!/bin/bash
+## Copyright (c) Microsoft Corporation. All rights reserved.
+# shellcheck disable=SC1091
+
+set -x 
+
+SUBM=$1
+
+HERE="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd)"
+
+pushd .
+cd "$HERE" || exit 1
+
+pushd .
+cd ../../
+sudo docker build -f $HERE/Dockerfile  --no-cache --force-rm -t srsran-jbpf .
+popd || exit 1
+
+popd || exit 1
+
+exit 0
+
diff --git a/srsran_jbpf/reverse_proxy/CMakeLists.txt b/srsran_jbpf/reverse_proxy/CMakeLists.txt
new file mode 100644
index 000000000..bf95f9559
--- /dev/null
+++ b/srsran_jbpf/reverse_proxy/CMakeLists.txt
@@ -0,0 +1,67 @@
+cmake_minimum_required(VERSION 3.16)
+
+# Project name
+project(srsranReverseProxyProject LANGUAGES CXX)
+
+# Set C++ standard
+set(CMAKE_CXX_STANDARD 17)
+set(CMAKE_CXX_STANDARD_REQUIRED ON)
+set(CMAKE_CXX_EXTENSIONS OFF)
+SET(CMAKE_CXX_FLAGS "-std=c++17")
+
+# Binary name
+set(BINARY_NAME srsran_reverse_proxy)
+
+# check that required jbpf libraries are present
+#set(JBPF_VERIFIER_LIB ${JBPF_LIB_DIR}/libjbpf_verifier.a)
+#message(STATUS "JBPF_VERIFIER_LIB: ${JBPF_VERIFIER_LIB}")
+#if(NOT EXISTS "${JBPF_VERIFIER_LIB}")
+#    message(FATAL_ERROR "Required file not found at ${JBPF_VERIFIER_LIB}. Please ensure the file exists before running CMake.")
+#endif()
+
+
+set(JBPF_REVERSE_PROXY_PATH $ENV{JBPF_PATH}/examples/reverse_proxy)
+set(JBPF_REVERSE_PROXY_LIB ${JBPF_REVERSE_PROXY_PATH}/libreverse_proxy.a)
+#message(STATUS "JBPF_REVERSE_PROXY_LIB: ${JBPF_REVERSE_PROXY_LIB}")
+#if(NOT EXISTS "${JBPF_REVERSE_PROXY_LIB}")
+#    message(FATAL_ERROR "Required file not found at ${JBPF_REVERSE_PROXY_LIB}. Please ensure the file exists before running CMake.")
+#endif()
+
+
+# Include directories
+include_directories(
+    $ENV{JBPF_OUT_DIR}/inc
+    $ENV{JBPF_PATH}/examples/reverse_proxy
+)
+
+# Linker flags
+set(LINK_LIBS
+    srsran::verifier_lib
+    jbpf::core_lib 
+    jbpf::lcm_ipc_lib
+    jbpf::verifier_lib
+    jbpf::reverse_proxy_lib
+
+    boost_program_options
+    ck
+    mimalloc
+    pthread
+    dl
+    rt
+)
+
+
+link_directories($ENV{JBPF_OUT_DIR}/lib ${JBPF_REVERSE_PROXY_PATH})
+
+# Add executable for main.cpp and link with the static library
+add_executable(${BINARY_NAME} main.cpp)
+
+# store executable in the current directory
+set_target_properties(${BINARY_NAME}
+    PROPERTIES
+    RUNTIME_OUTPUT_DIRECTORY "${OUTPUT_DIR}/bin"
+)
+
+# Link the static library and additional libraries with the executable
+target_link_libraries(${BINARY_NAME} ${LINK_LIBS} ${LINK_LIBS} ${LINK_FLAGS})
+
diff --git a/srsran_jbpf/reverse_proxy/main.cpp b/srsran_jbpf/reverse_proxy/main.cpp
new file mode 100644
index 000000000..f3d4d7d4e
--- /dev/null
+++ b/srsran_jbpf/reverse_proxy/main.cpp
@@ -0,0 +1,15 @@
+
+#include "listener.hpp"
+#include "parser.hpp"
+#include "jbpf_verifier.hpp"
+#include "srsran_verifier.hpp"
+
+int
+main(int ac, char** av)
+{
+    // register the "jbpf_verify" function
+    jbpf_reverse_proxy::parser::parser_jbpf_set_verify_func(srsran_verify);
+
+    // run the listener
+    return jbpf_reverse_proxy::listener::run_listener(ac, av);
+}
\ No newline at end of file
diff --git a/srsran_jbpf/verifier/CMakeLists.txt b/srsran_jbpf/verifier/CMakeLists.txt
new file mode 100644
index 000000000..c495eea50
--- /dev/null
+++ b/srsran_jbpf/verifier/CMakeLists.txt
@@ -0,0 +1,48 @@
+cmake_minimum_required(VERSION 3.16)
+
+project(srsranVerifier)
+
+######## srsran verifier library ########
+
+set(SRSRAN_VERIFIER_LIB srsran_verifier)
+set(SRSRAN_VERIFIER_SRC_DIR ${PROJECT_SOURCE_DIR})
+set(SRSRAN_VERIFIER_SOURCES ${SRSRAN_VERIFIER_SRC_DIR}/srsran_verifier.cpp)
+set(SRSRAN_VERIFIER_SPECS_HEADERS ${SRSRAN_VERIFIER_SRC_DIR}/specs)
+set(SRSRAN_VERIFIER_HEADERS ${SRSRAN_VERIFIER_SRC_DIR} ${SRSRAN_VERIFIER_SPECS_HEADERS})
+
+set(JBPF_EBPF_VERIFIER_HEADERS ${JBPF_PATH}/3p/ebpf-verifier/external ${JBPF_PATH}/3p/ebpf-verifier/src)
+set(JBPF_VERIFIER_HEADERS ${JBPF_PATH}/src/verifier ${JBPF_EBPF_VERIFIER_HEADERS})
+
+add_library(${SRSRAN_VERIFIER_LIB} ${SRSRAN_VERIFIER_SOURCES})
+add_library(srsran::verifier_lib ALIAS ${SRSRAN_VERIFIER_LIB})
+target_include_directories(${SRSRAN_VERIFIER_LIB} PUBLIC ${SRSRAN_VERIFIER_HEADERS} ${JBPF_VERIFIER_HEADERS} )
+
+set_target_properties(${SRSRAN_VERIFIER_LIB}
+    PROPERTIES
+    ARCHIVE_OUTPUT_DIRECTORY  "${OUTPUT_DIR}/lib"
+    LIBRARY_OUTPUT_DIRECTORY  "${OUTPUT_DIR}/lib"
+)
+
+add_custom_command(TARGET ${SRSRAN_VERIFIER_LIB} POST_BUILD
+  COMMAND ${CMAKE_COMMAND} -E make_directory ${OUTPUT_DIR}/inc/
+  COMMAND ${CMAKE_COMMAND} -E copy  ${SRSRAN_VERIFIER_SRC_DIR}/srsran_verifier.h* ${OUTPUT_DIR}/inc/  
+)
+
+
+######## srsran verifier cli ########
+
+set(SRSRAN_VERIFIER_CLI srsran_verifier_cli)
+set(SRSRAN_VERIFIER_CLI_SOURCES ${SRSRAN_VERIFIER_SRC_DIR}/srsran_verifier_cli.cpp)
+
+add_executable(${SRSRAN_VERIFIER_CLI} ${SRSRAN_VERIFIER_CLI_SOURCES})
+target_include_directories(${SRSRAN_VERIFIER_CLI} PUBLIC ${SRSRAN_VERIFIER_HEADERS} ${JBPF_EBPF_VERIFIER_HEADERS})
+target_link_libraries(${SRSRAN_VERIFIER_CLI} jbpf::verifier_lib ${SRSRAN_VERIFIER_LIB} jbpf::verifier_lib)
+
+
+set_target_properties(${SRSRAN_VERIFIER_CLI}
+    PROPERTIES
+    RUNTIME_OUTPUT_DIRECTORY "${OUTPUT_DIR}/bin"
+)
+
+######## Export header files for other projects ############
+set(SRSRAN_VERIFIER_SPECS_HEADERS ${SRSRAN_VERIFIER_SPECS_HEADERS} PARENT_SCOPE)
diff --git a/srsran_jbpf/verifier/specs/context_descriptors.hpp b/srsran_jbpf/verifier/specs/context_descriptors.hpp
new file mode 100644
index 000000000..78dbd1350
--- /dev/null
+++ b/srsran_jbpf/verifier/specs/context_descriptors.hpp
@@ -0,0 +1,27 @@
+#pragma once
+
+/* OFH context*/
+// struct jbpf_ran_ofh_ctx {
+//   uint64_t data; /* Pointer to beginning of buffer with int16_t IQ samples */
+//   uint64_t data_end; /* Pointer to end+1 of packet */
+//   uint64_t meta_data; /* Used for the program to store metadata */
+//   /* Combination of frame, slot and cell_id, provide a unique
+//      context for an execution pipeline */
+//   uint16_t ctx_id; /* Context id (could be implementation specific) */
+//   uint8_t direction; /* 0 DL, 1 UL */
+// };
+constexpr int jbpf_srsran_ofh_regions = 3 * 8 + 1 * 2 + 1;
+constexpr ebpf_context_descriptor_t jbpf_srsran_ofh_descr = {jbpf_srsran_ofh_regions, 0, 1 * 8, 2 * 8};
+
+/* L2 context*/
+// struct jbpf_ran_layer2_ctx {
+//     uint64_t data; /* Pointer to beginning of variable-sized L2 struct */
+//     uint64_t data_end; /* Pointer to end+1 of variable-sized struct */
+//     uint64_t meta_data; /* Used for the program to store metadata */
+//     uint16_t ctx_id; /* Context id (could be implementation specific) */
+//     uint16_t frame; /* 3GPP frame number */
+//     uint16_t slot; /* 3GPP slot number */
+//     uint16_t cell_id; /* Cell id */
+// };
+constexpr int jbpf_srsran_layer2_regions = 3 * 8 + 4 * 2;
+constexpr ebpf_context_descriptor_t jbpf_srsran_layer2_descr = {jbpf_srsran_layer2_regions, 0, 1 * 8, 2 * 8};
diff --git a/include/srsran/jbpf/jbpf_srsran_hooks.h b/srsran_jbpf/verifier/specs/jbpf_srsran_hooks.h
similarity index 85%
rename from include/srsran/jbpf/jbpf_srsran_hooks.h
rename to srsran_jbpf/verifier/specs/jbpf_srsran_hooks.h
index fa68cae76..7e412bfcf 100644
--- a/include/srsran/jbpf/jbpf_srsran_hooks.h
+++ b/srsran_jbpf/verifier/specs/jbpf_srsran_hooks.h
@@ -1,8 +1,14 @@
-#ifndef JBPF_HOOKS_
-#define JBPF_HOOKS_
+#ifndef JBPF_SRSRAN_HOOKS_
+#define JBPF_SRSRAN_HOOKS_
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
 
 #include "jbpf_hook.h"
 #include "jbpf_srsran_defs.h"
+#include "jbpf_srsran_contexts.h"
 
 DECLARE_JBPF_HOOK(capture_xran_packet,
 		   struct jbpf_ran_ofh_ctx ctx,
@@ -41,4 +47,9 @@ DECLARE_JBPF_HOOK(mac_bsr_update,
 			       )
 		   )
 
-#endif
\ No newline at end of file
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif // JBPF_SRSRAN_HOOKS_
diff --git a/srsran_jbpf/verifier/srsran_verifier.cpp b/srsran_jbpf/verifier/srsran_verifier.cpp
new file mode 100644
index 000000000..9e34183a2
--- /dev/null
+++ b/srsran_jbpf/verifier/srsran_verifier.cpp
@@ -0,0 +1,44 @@
+
+#include "srsran_verifier.hpp"
+#include "jbpf_helper_api_defs_ext.h"
+#include "context_descriptors.hpp"
+#include "jbpf_srsran_contexts.h"
+
+
+
+using std::string;
+using std::vector;
+
+
+
+jbpf_verifier_result_t
+srsran_verify(const char* objfile, const char* section, const char* asmfile)
+{
+    // register jbpf_srsran_ofh program type
+    {
+        // Next, we define the new program type
+        EbpfProgramType new_program_type;
+        new_program_type.name = "jbpf_srsran_ofh";
+        new_program_type.context_descriptor = &jbpf_srsran_ofh_descr;
+        new_program_type.section_prefixes = {
+            "jbpf_srsran_ofh"}; // The name(s) used to define the ELF section,
+                               // where the codelet function is stored for this program type
+        new_program_type.is_privileged = false;
+        jbpf_verifier_register_program_type(JBPF_PROG_TYPE_SRSRAN_OFH, new_program_type);
+    }
+
+    // register jbpf_srsran_layer2 program type
+    {
+        // Next, we define the new program type
+        EbpfProgramType new_program_type;
+        new_program_type.name = "jbpf_srsran_layer2";
+        new_program_type.context_descriptor = &jbpf_srsran_layer2_descr;
+        new_program_type.section_prefixes = {
+            "jbpf_srsran_layer2"}; // The name(s) used to define the ELF section,
+                               // where the codelet function is stored for this program type
+        new_program_type.is_privileged = false;
+        jbpf_verifier_register_program_type(JBPF_PROG_TYPE_SRSRAN_OFH, new_program_type);
+    }
+
+    return jbpf_verify(objfile, section, asmfile);
+}
diff --git a/srsran_jbpf/verifier/srsran_verifier.hpp b/srsran_jbpf/verifier/srsran_verifier.hpp
new file mode 100644
index 000000000..40ef06a1f
--- /dev/null
+++ b/srsran_jbpf/verifier/srsran_verifier.hpp
@@ -0,0 +1,16 @@
+#pragma once
+
+#include "jbpf_verifier.hpp"
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    jbpf_verifier_result_t
+    srsran_verify(const char* filename, const char* section, const char* asmfile);
+
+#ifdef __cplusplus
+}
+#endif
+
diff --git a/srsran_jbpf/verifier/srsran_verifier_cli.cpp b/srsran_jbpf/verifier/srsran_verifier_cli.cpp
new file mode 100644
index 000000000..a858a17c4
--- /dev/null
+++ b/srsran_jbpf/verifier/srsran_verifier_cli.cpp
@@ -0,0 +1,48 @@
+#include "CLI11.hpp"
+
+#include "srsran_verifier.hpp"
+
+int
+main(int argc, char** argv)
+{
+    CLI::App app{"FlexRAN verifier"};
+    const char *asm_file, *section;
+    jbpf_verifier_result_t result;
+
+    std::string filename;
+    app.add_option("path", filename, "Elf file to analyze")->required()->type_name("FILE");
+
+    std::string desired_section;
+    app.add_option("section", desired_section, "Section to analyze")->type_name("SECTION");
+
+    std::string asmfile;
+    app.add_option("--asm", asmfile, "Print disassembly to FILE")->type_name("FILE");
+
+    CLI11_PARSE(app, argc, argv);
+
+    if (desired_section.empty()) {
+        section = nullptr;
+    } else {
+        section = desired_section.c_str();
+    }
+
+    if (asmfile.empty()) {
+        asm_file = nullptr;
+    } else {
+        asm_file = asmfile.c_str();
+    }
+
+    result = srsran_verify(filename.c_str(), section, asm_file);
+
+    int res;
+    if (result.verification_pass) {
+        res = 1;
+    } else {
+        res = 0;
+    }
+
+    std::cout << result.verification_pass << "," << result.runtime_seconds << std::endl;
+    std::cout << "Program terminates within " << result.max_instruction_count << " instructions\n";
+
+    return !res;
+}
\ No newline at end of file
